<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>‚öΩ FC WAR ‚Äî Ultimate Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800;900&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #00ff87;
      --primary-dark: #00cc6a;
      --secondary: #ff6b35;
      --secondary-dark: #ff4500;
      --gold: #ffd700;
      --gold-dark: #ffb700;
      --dark: #0a0e27;
      --dark-light: #1a1f3a;
      --card-gold: linear-gradient(135deg, #f9d423 0%, #ff4e50 100%);
      --card-icon: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --card-back: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    html, body {
      height: 100%;
      font-family: 'Poppins', sans-serif;
      overflow-x: hidden;
    }

    body {
      background: var(--dark);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
    }

    /* Animated background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse at top, rgba(0, 255, 135, 0.15), transparent 50%),
        radial-gradient(ellipse at bottom, rgba(102, 126, 234, 0.15), transparent 50%),
        linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0a0e27 100%);
      background-size: 100% 100%, 100% 100%, 100% 100%;
      animation: bgShift 30s ease infinite;
      z-index: -1;
    }

    @keyframes bgShift {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    /* Floating particles */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: -1;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--primary);
      border-radius: 50%;
      opacity: 0.3;
      animation: float 15s infinite;
    }

    @keyframes float {
      0% { transform: translateY(0) translateX(0); opacity: 0; }
      5% { opacity: 0.2; }
      95% { opacity: 0.2; }
      100% { transform: translateY(-100vh) translateX(50px); opacity: 0; }
    }

    .card {
      background: rgba(26, 31, 58, 0.95);
      border-radius: 24px;
      padding: 32px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 100px rgba(102, 126, 234, 0.2),
        inset 0 0 20px rgba(255, 255, 255, 0.05);
      max-width: 1100px;
      width: 100%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      animation: slideIn 0.5s ease;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .center { text-align: center; }

    h1 {
      font-size: 48px;
      font-weight: 900;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      text-shadow: 0 0 30px rgba(0, 255, 135, 0.5);
      letter-spacing: 2px;
    }

    h2 {
      font-size: 32px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), #fff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 16px;
    }

    .muted {
      color: #8b92b0;
      font-size: 15px;
      margin-bottom: 24px;
    }

    input[type="text"] {
      width: 100%;
      padding: 16px 20px;
      border-radius: 16px;
      border: 2px solid rgba(102, 126, 234, 0.3);
      background: rgba(26, 31, 58, 0.8);
      color: #fff;
      font-size: 16px;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      transition: all 0.3s ease;
      outline: none;
    }

    input[type="text"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 20px rgba(0, 255, 135, 0.3);
      transform: translateY(-2px);
    }

    input[type="text"]::placeholder {
      color: #5a6080;
    }

    button {
      padding: 16px 32px;
      border-radius: 16px;
      border: none;
      cursor: pointer;
      font-weight: 800;
      font-size: 16px;
      font-family: 'Poppins', sans-serif;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(-1px);
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: var(--dark);
      box-shadow: 0 8px 25px rgba(0, 255, 135, 0.4);
    }

    .btn-blue {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    .btn-purple {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      color: #fff;
      box-shadow: 0 8px 25px rgba(240, 147, 251, 0.4);
    }

    .btn-red {
      background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
      color: #fff;
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
    }

    .btn-disabled {
      background: rgba(50, 55, 80, 0.5) !important;
      color: #5a6080 !important;
      cursor: not-allowed !important;
      box-shadow: none !important;
    }

    .btn-disabled:hover {
      transform: none !important;
    }

    /* FIFA-style Player Card */
    .player-card {
      width: 160px;
      height: 220px;
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .player-card:hover {
      transform: translateY(-8px) scale(1.05);
      filter: brightness(1.1);
    }

    .player-card.minimal {
      width: 100px;
      height: 140px;
    }

    .player-card.winner {
      border: 4px solid var(--primary);
      box-shadow: 
        0 0 20px rgba(0, 255, 135, 0.6),
        0 0 40px rgba(0, 255, 135, 0.4),
        0 10px 30px rgba(0, 0, 0, 0.5);
      animation: winnerGlow 1.5s ease-in-out infinite;
    }

    @keyframes winnerGlow {
      0%, 100% { 
        box-shadow: 
          0 0 20px rgba(0, 255, 135, 0.6),
          0 0 40px rgba(0, 255, 135, 0.4),
          0 10px 30px rgba(0, 0, 0, 0.5);
      }
      50% { 
        box-shadow: 
          0 0 30px rgba(0, 255, 135, 0.8),
          0 0 60px rgba(0, 255, 135, 0.6),
          0 10px 30px rgba(0, 0, 0, 0.5);
      }
    }

    .card-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--card-gold);
      padding: 16px;
      display: flex;
      flex-direction: column;
      color: #fff;
    }

    .card-background.icon {
      background: var(--card-icon);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .card-rating {
      font-size: 36px;
      font-weight: 900;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      line-height: 1;
    }

    .card-rating.minimal {
      font-size: 28px;
    }

    .card-position {
      font-size: 14px;
      font-weight: 800;
      opacity: 0.95;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    }

    .card-nation {
      font-size: 32px;
      text-align: center;
      margin: 8px 0;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    .card-nation.minimal {
      font-size: 24px;
      margin: 4px 0;
    }

    .card-name {
      font-size: 16px;
      font-weight: 900;
      text-align: center;
      text-transform: uppercase;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      line-height: 1.2;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-name.minimal {
      font-size: 12px;
    }

    .card-club {
      font-size: 11px;
      text-align: center;
      opacity: 0.9;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
      font-weight: 700;
    }

    .icon-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(10px);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: iconPulse 3s ease infinite;
    }

    .icon-badge.minimal {
      width: 24px;
      height: 24px;
      font-size: 14px;
      top: 6px;
      right: 6px;
    }

    @keyframes iconPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4); }
    }

    .card-back {
      width: 160px;
      height: 220px;
      border-radius: 16px;
      background: var(--card-back);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      position: relative;
      overflow: hidden;
    }

    .card-back::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shimmer 4s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
      100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
    }

    .card-placeholder {
      width: 160px;
      height: 220px;
      border: 3px dashed rgba(102, 126, 234, 0.4);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: rgba(102, 126, 234, 0.3);
    }

    .stat-box {
      background: rgba(26, 31, 58, 0.8);
      padding: 16px 20px;
      border-radius: 16px;
      border: 1px solid rgba(102, 126, 234, 0.3);
      min-width: 140px;
      transition: all 0.3s ease;
    }

    .stat-box:hover {
      border-color: var(--primary);
      box-shadow: 0 0 20px rgba(0, 255, 135, 0.2);
      transform: translateY(-2px);
    }

    .small {
      font-size: 12px;
      color: #8b92b0;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .bignum {
      font-size: 32px;
      font-weight: 900;
      background: linear-gradient(135deg, var(--primary), #fff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .status {
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      margin: 20px 0;
      padding: 16px;
      background: rgba(102, 126, 234, 0.2);
      border-radius: 12px;
      border: 1px solid rgba(102, 126, 234, 0.3);
    }

    .battle-area {
      display: flex;
      gap: 40px;
      align-items: center;
      justify-content: center;
      margin: 32px 0;
      padding: 32px;
      background: rgba(26, 31, 58, 0.5);
      border-radius: 20px;
      border: 1px solid rgba(102, 126, 234, 0.2);
      position: relative;
    }

    .vs-symbol {
      font-size: 48px;
      font-weight: 900;
      background: linear-gradient(135deg, var(--secondary), var(--gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: pulse 2.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.9; }
    }

    .player-info {
      text-align: center;
      margin-bottom: 16px;
    }

    .player-name {
      font-size: 18px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .icons-display {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
      padding: 20px;
      background: rgba(26, 31, 58, 0.5);
      border-radius: 16px;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }

    .section-title {
      font-size: 14px;
      font-weight: 800;
      color: var(--primary);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 12px;
      text-align: center;
    }

    .room-code-box {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
      padding: 24px;
      border-radius: 20px;
      margin: 24px 0;
      border: 2px solid rgba(102, 126, 234, 0.4);
      box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
    }

    .room-code {
      font-size: 42px;
      font-weight: 900;
      color: var(--primary);
      margin: 12px 0;
      letter-spacing: 8px;
      text-shadow: 0 0 20px rgba(0, 255, 135, 0.5);
    }

    .waiting-spinner {
      font-size: 64px;
      animation: spin 5s linear infinite;
      display: inline-block;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
    }

    .divider {
      text-align: center;
      margin: 16px 0;
      color: #8b92b0;
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 16px;
      margin: 20px 0;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      margin-bottom: 24px;
      padding: 20px;
      background: rgba(26, 31, 58, 0.5);
      border-radius: 20px;
      border: 1px solid rgba(102, 126, 234, 0.2);
      flex-wrap: wrap;
    }

    .player-section {
      flex: 1;
      min-width: 200px;
    }

    .winner-animation {
      animation: winPulse 1s ease infinite;
    }

    @keyframes winPulse {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2) drop-shadow(0 0 15px var(--gold)); }
    }

    @keyframes iconDestroy {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2) rotate(10deg); opacity: 0.5; }
      100% { transform: scale(0) rotate(45deg); opacity: 0; }
    }

    .icon-destroyed {
      animation: iconDestroy 0.6s ease-out forwards;
    }

    .card-appear {
      animation: cardAppear 0.5s ease;
    }

    @keyframes cardAppear {
      from { opacity: 0; transform: scale(0.8) rotateY(90deg); }
      to { opacity: 1; transform: scale(1) rotateY(0deg); }
    }

    @media (max-width: 768px) {
      h1 { font-size: 36px; }
      h2 { font-size: 24px; }
      .player-card { width: 120px; height: 165px; }
      .card-back { width: 120px; height: 165px; }
      .card-placeholder { width: 120px; height: 165px; }
      .battle-area { flex-direction: column; gap: 20px; padding: 20px; }
      .vs-symbol { font-size: 32px; }
      .room-code { font-size: 32px; letter-spacing: 4px; }
      .top-bar { flex-direction: column; }
    }

    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  <div id="app" class="card"></div>

  <script>
  // Create floating particles
  (function createParticles() {
    const container = document.getElementById('particles');
    for(let i = 0; i < 30; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.animationDelay = Math.random() * 15 + 's';
      particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
      container.appendChild(particle);
    }
  })();

  // ===========================
  // FC WAR ‚Äî Enhanced Edition
  // ===========================

  const PLAYERS = [
    { name: 'Sergi Roberto', overall: 79, position: 'RB', club: 'Como', nation: 'Spain' },
    { name: 'Brais M√©ndez', overall: 79, position: 'CM', club: 'Real Sociedad', nation: 'Spain' },
    { name: 'Lucas Paquet√°', overall: 82, position: 'CAM', club: 'West Ham', nation: 'Brazil' },
    { name: 'Gianluca Mancini', overall: 80, position: 'CB', club: 'AS Roma', nation: 'Italy' },
    { name: 'Naby Ke√Øta', overall: 79, position: 'CM', club: 'Werder Bremen', nation: 'Guinea' },
    { name: 'Ot√°vio', overall: 80, position: 'CAM', club: 'Al-Nassr', nation: 'Portugal' },
    { name: 'Mateo Kovaƒçiƒá', overall: 82, position: 'CDM', club: 'Man City', nation: 'Croatia' },
    { name: 'Gabriel Jesus', overall: 82, position: 'ST', club: 'Arsenal', nation: 'Brazil' },
    { name: 'Jules Kound√©', overall: 82, position: 'CB', club: 'Barcelona', nation: 'France' },
    { name: 'Ibrahima Konat√©', overall: 81, position: 'CB', club: 'Liverpool', nation: 'France' },
    { name: 'Aur√©lien Tchouam√©ni', overall: 82, position: 'CDM', club: 'Real Madrid', nation: 'France' },
    { name: 'Lautaro Mart√≠nez', overall: 85, position: 'ST', club: 'Inter Milan', nation: 'Argentina' },
    { name: 'R√∫ben Dias', overall: 85, position: 'CB', club: 'Man City', nation: 'Portugal' },
    { name: 'Bruno Fernandes', overall: 84, position: 'CAM', club: 'Man United', nation: 'Portugal' },
    { name: 'Ederson', overall: 85, position: 'GK', club: 'Man City', nation: 'Brazil' },
    { name: 'Jamal Musiala', overall: 84, position: 'CAM', club: 'Bayern M√ºnchen', nation: 'Germany' },
    { name: 'Nicol√≤ Barella', overall: 84, position: 'CM', club: 'Inter Milan', nation: 'Italy' },
    { name: 'Alejandro Grimaldo', overall: 83, position: 'LB', club: 'Leverkusen', nation: 'Spain' },
    { name: '√Ålex Baena', overall: 83, position: 'LW', club: 'Villarreal', nation: 'Spain' },
    { name: 'Vitinha', overall: 83, position: 'CM', club: 'PSG', nation: 'Portugal' },
    { name: 'Federico Valverde', overall: 85, position: 'CM', club: 'Real Madrid', nation: 'Uruguay' },
    { name: 'Bernardo Silva', overall: 85, position: 'RW', club: 'Man City', nation: 'Portugal' },
    { name: 'Declan Rice', overall: 84, position: 'CDM', club: 'Arsenal', nation: 'England' },
    { name: 'Victor Osimhen', overall: 85, position: 'ST', club: 'Galatasaray', nation: 'Nigeria' },
    { name: 'Bukayo Saka', overall: 87, position: 'RW', club: 'Arsenal', nation: 'England' },
    { name: 'Joshua Kimmich', overall: 87, position: 'CDM', club: 'Bayern M√ºnchen', nation: 'Germany' },
    { name: 'Martin √òdegaard', overall: 87, position: 'CAM', club: 'Arsenal', nation: 'Norway' },
    { name: 'Florian Wirtz', overall: 86, position: 'CAM', club: 'Leverkusen', nation: 'Germany' },
    { name: 'Rafael Le√£o', overall: 86, position: 'LW', club: 'AC Milan', nation: 'Portugal' },
    { name: 'Thibaut Courtois', overall: 87, position: 'GK', club: 'Real Madrid', nation: 'Belgium' },
    { name: 'Marquinhos', overall: 86, position: 'CB', club: 'PSG', nation: 'Brazil' },
    { name: 'Heung-Min Son', overall: 87, position: 'LW', club: 'Tottenham', nation: 'South Korea' },
    { name: 'Phil Foden', overall: 87, position: 'CAM', club: 'Man City', nation: 'England' },
    { name: 'Harry Kane', overall: 89, position: 'ST', club: 'Bayern M√ºnchen', nation: 'England' },
    { name: 'Virgil van Dijk', overall: 88, position: 'CB', club: 'Liverpool', nation: 'Netherlands' },
    { name: 'Alisson', overall: 88, position: 'GK', club: 'Liverpool', nation: 'Brazil' },
    { name: 'Kevin De Bruyne', overall: 89, position: 'CAM', club: 'Man City', nation: 'Belgium' },
    { name: 'Mohamed Salah', overall: 89, position: 'RW', club: 'Liverpool', nation: 'Egypt' },
    { name: 'Vin√≠cius Jr', overall: 89, position: 'LW', club: 'Real Madrid', nation: 'Brazil' },
    { name: 'Erling Haaland', overall: 91, position: 'ST', club: 'Man City', nation: 'Norway' },
    { name: 'Kylian Mbapp√©', overall: 91, position: 'ST', club: 'Real Madrid', nation: 'France' },
    { name: 'Jude Bellingham', overall: 90, position: 'CAM', club: 'Real Madrid', nation: 'England' },
    { name: 'Rodri', overall: 91, position: 'CDM', club: 'Man City', nation: 'Spain' },
    { name: 'Lionel Messi', overall: 90, position: 'RW', club: 'Inter Miami', nation: 'Argentina' },
    { name: 'Cristiano Ronaldo', overall: 88, position: 'ST', club: 'Al-Nassr', nation: 'Portugal' },
    { name: 'Neymar Jr', overall: 87, position: 'LW', club: 'Al-Hilal', nation: 'Brazil' },
    { name: 'Robert Lewandowski', overall: 88, position: 'ST', club: 'Barcelona', nation: 'Poland' },
    { name: 'Luka Modriƒá', overall: 86, position: 'CM', club: 'Real Madrid', nation: 'Croatia' },
  ];

  const ICONS = [
    { name: 'Zinedine Zidane', overall: 96, position: 'CAM', nation: 'France' },
    { name: 'Ronaldo Naz√°rio', overall: 96, position: 'ST', nation: 'Brazil' },
    { name: 'Pel√©', overall: 98, position: 'CAM', nation: 'Brazil' },
    { name: 'Diego Maradona', overall: 97, position: 'CAM', nation: 'Argentina' },
    { name: 'Johan Cruyff', overall: 96, position: 'CF', nation: 'Netherlands' },
    { name: 'Ronaldinho', overall: 95, position: 'CAM', nation: 'Brazil' },
    { name: 'Thierry Henry', overall: 95, position: 'ST', nation: 'France' },
    { name: 'Paolo Maldini', overall: 96, position: 'CB', nation: 'Italy' },
  ];

  const state = {
    gameMode: null,
    gameState: 'menu',
    playerName: '',
    inputName: localStorage.getItem('war_game_player_name') || '',
    opponentName: 'Bot',
    currentDrawnIcon: 0,
    playerDeck: [],
    opponentDeck: [],
    playerCard: null,
    opponentCard: null,
    message: '',
    winner: null,
    canPlay: true,
    isProcessing: false,
    lastWinner: 'player',
    lastRoundWinner: null, // 'player' | 'opponent' | null
    collectedPlayerCards: 0,
    collectedOpponentCards: 0,
    player1Icons: [],
    player2Icons: [],
    myActiveIcons: [],
    opponentActiveIcons: [],
    roomCode: '',
    inputRoomCode: '',
    isHost: false,
    copied: false,
    intervalId: null
  };

  function shuffle(array) {
    const arr = [...array];
    for(let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }


  function renderCardHTML(card, minimal = false, faceDown = false, isWinner = false) {
    if(!card) {
      return '<div class="card-placeholder">?</div>';
    }
    
    if(faceDown) {
      return `
        <div class="card-back">
          <span style="position: relative; z-index: 1;">‚öΩ</span>
        </div>
      `;
    }

    const isIcon = card.type === 'icon';
    const cardClass = isIcon ? 'icon' : '';
    const nameShort = (card.name || '').split(' ').pop();
    const nationEmoji = nationFlag(card.nation);
    const minimalClass = minimal ? 'minimal' : '';
    const winnerClass = isWinner ? 'winner' : '';
    
    return `
      <div class="player-card ${minimalClass} ${winnerClass}">
        <div class="card-background ${cardClass}">
          <div class="card-header">
            <div class="card-rating ${minimalClass}">${card.overall}</div>
            <div class="card-position">${card.position}</div>
          </div>
          <div class="card-nation ${minimalClass}">${nationEmoji}</div>
          <div class="card-name ${minimalClass}">${nameShort}</div>
          ${!minimal ? `<div class="card-club">${card.club || card.nation}</div>` : ''}
        </div>
        ${isIcon ? `<div class="icon-badge ${minimalClass}">‚≠ê</div>` : ''}
      </div>
    `;
  }

  function nationFlag(n) {
    const flags = {
      'Brazil': 'üáßüá∑', 'Argentina': 'üá¶üá∑', 'France': 'üá´üá∑', 'England': 'üè¥ÛêÅßÛêÅ¢ÛêÅ•ÛêÅÆÛêÅßÛêÅø',
      'Portugal': 'üáµüáπ', 'Spain': 'üá™üá∏', 'Germany': 'üá©üá™', 'Belgium': 'üáßüá™',
      'Netherlands': 'üá≥üá±', 'Italy': 'üáÆüáπ', 'Norway': 'üá≥üá¥', 'Egypt': 'üá™üá¨',
      'Guinea': 'üá¨üá≥', 'Croatia': 'üá≠üá∑', 'South Korea': 'üá∞üá∑', 'Nigeria': 'üá≥üá¨',
      'Poland': 'üáµüá±', 'Uruguay': 'üá∫üáæ'
    };
    return flags[n] || 'üåç';
  }

  const app = document.getElementById('app');

  function render() {
    if(state.gameState === 'menu') return renderMenu();
    if(state.gameState === 'drawing') return renderDrawing();
    if(state.gameState === 'lobby') return renderLobby();
    if(state.gameState === 'playing') return renderPlaying();
    if(state.gameState === 'finished') return renderFinished();
  }

  function renderMenu() {
    app.innerHTML = `
      <div class="center">
        <h1>‚öΩ FC WAR ‚öΩ</h1>
        <p class="muted">Ultimate Card Battle ‚Äî Enhanced Edition</p>
      </div>
      
      <div style="margin-top: 24px">
        <input id="inputName" type="text" placeholder="üéÆ Wpisz swojƒÖ nazwƒô" value="${escapeHtml(state.inputName)}" />
      </div>

      <div class="button-group">
        <button id="btnBot" class="btn-blue">ü§ñ Graj z Botem</button>
        <button id="btnCreate" class="btn-purple">üåê Stw√≥rz Grƒô Online</button>
        
        <div class="divider">lub</div>
        
        <input id="inputRoomCode" type="text" placeholder="üîë Wpisz kod pokoju" value="${escapeHtml(state.inputRoomCode)}" />
        <button id="btnJoin" class="btn-primary">üéÆ Do≈ÇƒÖcz do Gry</button>
      </div>

      <p class="muted" style="margin-top: 24px; text-align: center;">
        üíæ Nazwa zapisywana lokalnie ‚Ä¢ üåê Tryb online przez localStorage
      </p>
    `;

    document.getElementById('inputName').addEventListener('input', (e) => {
      state.inputName = e.target.value;
      localStorage.setItem('war_game_player_name', state.inputName || '');
    });

    document.getElementById('inputRoomCode').addEventListener('input', (e) => {
      state.inputRoomCode = e.target.value.toUpperCase();
    });

    document.getElementById('btnBot').addEventListener('click', startBotGame);
    document.getElementById('btnCreate').addEventListener('click', createOnlineGame);
    document.getElementById('btnJoin').addEventListener('click', joinGame);
  }

  function renderDrawing() {
    const playerIconsHTML = state.player1Icons.map((icon, idx) => {
      const visible = idx <= state.currentDrawnIcon;
      return `
        <div style="transition: all 0.4s ease; transform: scale(${visible ? 1 : 0.6}); opacity: ${visible ? 1 : 0};">
          ${visible ? renderCardHTML(icon) : ''}
        </div>
      `;
    }).join('');

    const botIconsHTML = state.player2Icons.map((icon, idx) => {
      const visible = idx <= state.currentDrawnIcon;
      return `
        <div style="transition: all 0.4s ease; transform: scale(${visible ? 1 : 0.6}); opacity: ${visible ? 1 : 0};">
          ${visible ? renderCardHTML(null, false, true) : ''}
        </div>
      `;
    }).join('');

    app.innerHTML = `
      <div class="center">
        <h2>‚ú® Losowanie Legend! ‚ú®</h2>
        <p class="muted" style="margin-bottom: 32px;">Przeciwnik r√≥wnie≈º losuje swoje legendy...</p>
        
        <div style="margin: 32px 0;">
          <p class="section-title" style="color: var(--primary);">‚≠ê ${escapeHtml(state.playerName)} - Twoje Legendy</p>
          <div style="display: flex; gap: 20px; justify-content: center; margin: 18px 0;">
            ${playerIconsHTML}
          </div>
        </div>

        <div style="margin: 32px 0;">
          <p class="section-title" style="color: var(--secondary);">‚≠ê ${escapeHtml(state.opponentName)} - Legendy (Ukryte)</p>
          <div style="display: flex; gap: 20px; justify-content: center; margin: 18px 0;">
            ${botIconsHTML}
          </div>
        </div>

        <p class="status">üé≤ Losowanie ${Math.min(state.currentDrawnIcon + 1, 2)}/2</p>
      </div>
    `;
  }

  function cancelLobby() {
    if(confirm('Anulowaƒá oczekiwanie i wr√≥ciƒá do menu?')) {
      if(state.intervalId) {
        clearInterval(state.intervalId);
        state.intervalId = null;
      }
      if(state.roomCode) {
        try {
          localStorage.removeItem('war_game_' + state.roomCode);
        } catch(e) {}
      }
      resetGame();
    }
  }

  function renderLobby() {
    app.innerHTML = `
      <div class="center">
        <h2>üéÆ Pok√≥j Gry</h2>
        <div class="room-code-box">
          <p class="small">Kod pokoju:</p>
          <div class="room-code">${state.roomCode}</div>
          <p class="muted" style="margin-top: 12px;">Przeka≈º ten kod drugiej osobie</p>
        </div>
        <div style="margin-top: 32px;">
          <div class="waiting-spinner">‚è≥</div>
          <p class="status">${escapeHtml(state.message)}</p>
        </div>
        <div style="margin-top: 24px;">
          <button onclick="cancelLobby()" class="btn-red">‚ùå Anuluj i Wr√≥ƒá</button>
        </div>
      </div>
    `;
  }

  function renderFinished() {
    const winnerIsPlayer = state.winner === 'player';
    const winnerClass = winnerIsPlayer ? 'winner-animation' : '';
    
    app.innerHTML = `
      <div class="center">
        <h2 class="${winnerClass}">${winnerIsPlayer ? 'üèÜ ZWYCIƒòSTWO! üèÜ' : 'üò¢ PORA≈ªKA üò¢'}</h2>
        <p style="font-size: 24px; font-weight: 800; margin: 20px 0; color: var(--primary);">
          ${winnerIsPlayer ? escapeHtml(state.playerName) : escapeHtml(state.opponentName)} wygrywa!
        </p>

        <div style="background: rgba(26, 31, 58, 0.8); padding: 24px; border-radius: 20px; margin-top: 24px; border: 1px solid rgba(102, 126, 234, 0.3);">
          <p class="section-title">üìä Finalne Statystyki</p>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 16px;">
            <div style="text-align: center;">
              <p class="player-name" style="color: var(--primary);">${escapeHtml(state.playerName)}</p>
              <p style="font-size: 36px; font-weight: 900; margin: 12px 0;">‚úì ${state.collectedPlayerCards}</p>
              <p class="small">Wygrane rundy</p>
              <p class="small" style="margin-top: 8px;">üìö ${state.playerDeck.length} kart pozosta≈Ço</p>
            </div>
            <div style="text-align: center;">
              <p class="player-name" style="color: var(--secondary);">${escapeHtml(state.opponentName)}</p>
              <p style="font-size: 36px; font-weight: 900; margin: 12px 0;">‚úì ${state.collectedOpponentCards}</p>
              <p class="small">Wygrane rundy</p>
              <p class="small" style="margin-top: 8px;">üìö ${state.opponentDeck.length} kart pozosta≈Ço</p>
            </div>
          </div>
        </div>

        <div style="margin-top: 24px;">
          <button id="btnReset" class="btn-primary" style="min-width: 250px;">üîÑ Nowa Gra</button>
        </div>
      </div>
    `;

    document.getElementById('btnReset').addEventListener('click', resetGame);
  }

  function renderPlaying() {
    const myIconsHTML = state.myActiveIcons.length > 0 
      ? state.myActiveIcons.map(ic => renderCardHTML(ic, true)).join('') 
      : '<p class="muted">Straci≈Çe≈õ wszystkie legendy!</p>';
    
    const oppIconsHTML = state.opponentActiveIcons.length > 0 
      ? state.opponentActiveIcons.map(ic => renderCardHTML(ic, true)).join('') 
      : '<p class="muted">Przeciwnik straci≈Ç legendy!</p>';

    const canPlay = state.canPlay && !state.isProcessing && state.playerDeck.length > 0;
    const btnClass = canPlay ? 'btn-primary' : 'btn-disabled';

    // Determine if cards should show winner border
    const playerIsWinner = state.lastRoundWinner === 'player' && state.playerCard && state.opponentCard;
    const opponentIsWinner = state.lastRoundWinner === 'opponent' && state.playerCard && state.opponentCard;

    app.innerHTML = `
      <div>
        <div class="top-bar">
          <div class="player-section">
            <div class="player-name">${escapeHtml(state.opponentName)}</div>
            <div class="stats-grid" style="margin-top: 12px;">
              <div class="stat-box">
                <div class="small">Karty w talii</div>
                <div class="bignum">${state.opponentDeck.length}</div>
              </div>
              <div class="stat-box">
                <div class="small">Wygrane</div>
                <div class="bignum" style="color: var(--secondary);">${state.collectedOpponentCards}/10</div>
              </div>
            </div>
          </div>

          <div class="player-section">
            <div class="player-name" style="color: var(--primary);">${escapeHtml(state.playerName)}</div>
            <div class="stats-grid" style="margin-top: 12px;">
              <div class="stat-box">
                <div class="small">Karty w talii</div>
                <div class="bignum">${state.playerDeck.length}</div>
              </div>
              <div class="stat-box">
                <div class="small">Wygrane</div>
                <div class="bignum" style="color: var(--primary);">${state.collectedPlayerCards}/10</div>
              </div>
            </div>
          </div>
        </div>

        <div class="battle-area">
          <div>
            <div class="player-info">
              <div class="player-name">${escapeHtml(state.opponentName)}</div>
            </div>
            ${renderCardHTML(state.opponentCard, false, false, opponentIsWinner)}
          </div>
          
          <div class="vs-symbol">‚öîÔ∏è</div>
          
          <div>
            <div class="player-info">
              <div class="player-name" style="color: var(--primary);">${escapeHtml(state.playerName)}</div>
            </div>
            ${renderCardHTML(state.playerCard, false, false, playerIsWinner)}
          </div>
        </div>

        <div class="center">
          <p class="status">${escapeHtml(state.message)}</p>
          <button id="btnPlay" class="${btnClass}" style="min-width: 280px; margin-top: 16px;">
            ${state.isProcessing ? '‚è≥ Rozgrywam...' : 'üÉè Wy≈Ç√≥≈º Kartƒô'}
          </button>
        </div>

        <div class="icons-display">
          <div style="text-align: center; width: 100%;">
            <p class="section-title">‚≠ê Twoje Legendy ‚≠ê</p>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; margin-top: 12px;">
              ${myIconsHTML}
            </div>
          </div>
        </div>
      </div>
    `;

    if(canPlay) {
      document.getElementById('btnPlay').addEventListener('click', playCard);
    }
  }

  // Game logic functions (same as before but with updated state management)
  function generateRoomCode() {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
  }

  function generateGameLink() {
    return window.location.origin + window.location.pathname + '?room=' + state.roomCode;
  }

  function prepareGame() {
    const shuffledIcons = shuffle(ICONS);
    const p1Icons = shuffledIcons.slice(0, 2);
    const p2Icons = shuffledIcons.slice(2, 4);
    
    // Create 36 regular gold cards
    const shuffledPlayers = shuffle(PLAYERS);
    const selected36 = shuffledPlayers.slice(0, 36);
    const goldCards = selected36.map(player => ({...player, type: 'gold', id: player.name + '-' + Math.random()}));
    const shuffledGoldCards = shuffle(goldCards);
    
    // Split gold cards evenly: 18 for each player
    const p1GoldCards = shuffledGoldCards.slice(0, 18);
    const p2GoldCards = shuffledGoldCards.slice(18, 36);
    
    // Each player gets their own icons + their gold cards
    const p1Deck = [
      ...p1GoldCards,
      ...p1Icons.map(icon => ({...icon, type: 'icon', id: 'icon-p1-' + icon.name, owner: 'player1'}))
    ];
    const p2Deck = [
      ...p2GoldCards,
      ...p2Icons.map(icon => ({...icon, type: 'icon', id: 'icon-p2-' + icon.name, owner: 'player2'}))
    ];
    
    // Shuffle each player's deck
    const shuffledP1Deck = shuffle(p1Deck);
    const shuffledP2Deck = shuffle(p2Deck);
    
    return { p1Deck: shuffledP1Deck, p2Deck: shuffledP2Deck, p1Icons, p2Icons };
  }

  function startBotGame() {
    if(!state.inputName || !state.inputName.trim()) {
      alert('Wpisz swojƒÖ nazwƒô!');
      return;
    }
    
    state.playerName = state.inputName.trim();
    state.gameMode = 'bot';
    state.opponentName = 'Bot';
    
    const { p1Deck, p2Deck, p1Icons, p2Icons } = prepareGame();
    state.player1Icons = p1Icons;
    state.player2Icons = p2Icons;
    state.myActiveIcons = p1Icons.slice();
    state.opponentActiveIcons = p2Icons.slice();
    state.playerDeck = p1Deck.slice();
    state.opponentDeck = p2Deck.slice();
    state.gameState = 'drawing';
    state.currentDrawnIcon = 0;
    state.collectedPlayerCards = 0;
    state.collectedOpponentCards = 0;
    state.message = '';
    
    render();

    let tick = 0;
    const intId = setInterval(() => {
      state.currentDrawnIcon = tick;
      render();
      tick++;
      if(tick > 1) {
        clearInterval(intId);
        setTimeout(() => {
          state.gameState = 'playing';
          state.message = 'üéÆ Ty zaczynasz! Kliknij "Wy≈Ç√≥≈º Kartƒô"';
          state.lastWinner = 'player';
          render();
        }, 500);
      }
    }, 400);
  }

  function createOnlineGame() {
    if(!state.inputName || !state.inputName.trim()) {
      alert('Wpisz swojƒÖ nazwƒô!');
      return;
    }
    
    state.playerName = state.inputName.trim();
    state.gameMode = 'online';
    state.isHost = true;
    const code = generateRoomCode();
    state.roomCode = code;

    const { p1Deck, p2Deck, p1Icons, p2Icons } = prepareGame();
    state.player1Icons = p1Icons.slice();
    state.player2Icons = p2Icons.slice();
    state.myActiveIcons = p1Icons.slice();
    state.opponentActiveIcons = p2Icons.slice();
    state.playerDeck = p1Deck.slice();
    state.opponentDeck = p2Deck.slice();
    state.gameState = 'drawing';
    state.currentDrawnIcon = 0;
    state.collectedPlayerCards = 0;
    state.collectedOpponentCards = 0;
    
    render();

    let tick = 0;
    const intId = setInterval(() => {
      state.currentDrawnIcon = tick;
      render();
      tick++;
      if(tick > 1) {
        clearInterval(intId);
        setTimeout(() => {
          const gameData = {
            hostName: state.playerName,
            guestName: null,
            player1Icons: p1Icons,
            player2Icons: p2Icons,
            hostDeck: p1Deck,
            guestDeck: p2Deck,
            hostCollected: 0,
            guestCollected: 0,
            hostPlayed: false,
            guestPlayed: false,
            hostCard: null,
            guestCard: null,
            lastWinner: 'host',
            guestJoined: false,
            hostActiveIcons: p1Icons,
            guestActiveIcons: p2Icons,
            lastUpdate: Date.now()
          };
          try {
            localStorage.setItem('war_game_' + code, JSON.stringify(gameData));
          } catch(e) {}
          
          state.gameState = 'lobby';
          state.message = '‚è≥ Czekam na gracza...';
          render();
          startPolling(code);
        }, 500);
      }
    }, 400);
  }

  function joinGame() {
    if(!state.inputName || !state.inputName.trim()) {
      alert('Wpisz swojƒÖ nazwƒô!');
      return;
    }
    if(!state.inputRoomCode || !state.inputRoomCode.trim()) {
      alert('Wpisz kod pokoju!');
      return;
    }
    
    const code = state.inputRoomCode.toUpperCase();
    const raw = localStorage.getItem('war_game_' + code);
    
    if(!raw) {
      alert('Nie znaleziono pokoju o tym kodzie!');
      return;
    }
    
    try {
      const gameData = JSON.parse(raw);
      state.playerName = state.inputName.trim();
      state.opponentName = gameData.hostName || 'Gracz 1';
      state.roomCode = code;
      state.isHost = false;
      state.gameMode = 'online';
      state.player1Icons = gameData.player1Icons || [];
      state.player2Icons = gameData.player2Icons || [];
      state.myActiveIcons = gameData.guestActiveIcons || gameData.player2Icons || [];
      state.opponentActiveIcons = gameData.hostActiveIcons || gameData.player1Icons || [];
      state.playerDeck = gameData.guestDeck ? gameData.guestDeck.slice() : [];
      state.opponentDeck = gameData.hostDeck ? gameData.hostDeck.slice() : [];
      state.collectedPlayerCards = gameData.guestCollected || 0;
      state.collectedOpponentCards = gameData.hostCollected || 0;
      state.gameState = 'playing';
      
      const amIFirst = gameData.lastWinner === 'guest';
      state.lastWinner = amIFirst ? 'player' : 'opponent';
      state.message = amIFirst ? 'üéÆ Ty zaczynasz! Kliknij "Wy≈Ç√≥≈º kartƒô"' : '‚è≥ Przeciwnik zaczyna, czekaj...';
      state.canPlay = amIFirst;
      
      gameData.guestJoined = true;
      gameData.guestName = state.playerName;
      gameData.lastUpdate = Date.now();
      localStorage.setItem('war_game_' + code, JSON.stringify(gameData));
      
      startPolling(code);
      render();
    } catch(e) {
      alert('B≈ÇƒÖd przy wczytywaniu pokoju.');
    }
  }

  function startPolling(code) {
    if(state.intervalId) clearInterval(state.intervalId);
    
    state.intervalId = setInterval(() => {
      const raw = localStorage.getItem('war_game_' + code);
      if(!raw) return;
      
      try {
        const gameData = JSON.parse(raw);
        
        if(state.isHost && gameData.guestJoined && state.gameState === 'lobby') {
          state.opponentName = gameData.guestName || 'Gracz 2';
          state.gameState = 'playing';
          const hostFirst = gameData.lastWinner === 'host';
          state.lastWinner = hostFirst ? 'player' : 'opponent';
          state.message = hostFirst ? 'üéÆ Przeciwnik do≈ÇƒÖczy≈Ç! Ty zaczynasz!' : '‚è≥ Przeciwnik do≈ÇƒÖczy≈Ç! Przeciwnik zaczyna!';
          state.canPlay = hostFirst;
          render();
        }

        const opponentPlayed = state.isHost ? gameData.guestPlayed : gameData.hostPlayed;
        const iPlayed = state.isHost ? gameData.hostPlayed : gameData.guestPlayed;
        const opponentShouldGoFirst = state.isHost ? gameData.lastWinner === 'guest' : gameData.lastWinner === 'host';

        if(opponentShouldGoFirst && opponentPlayed && !iPlayed && !state.opponentCard) {
          const oppCard = state.isHost ? gameData.guestCard : gameData.hostCard;
          state.opponentCard = oppCard;
          state.message = '‚ö° Przeciwnik zagra≈Ç! Teraz Ty!';
          state.canPlay = true;
          render();
        }

        if(gameData.hostPlayed && gameData.guestPlayed) {
          const hCard = gameData.hostCard;
          const gCard = gameData.guestCard;
          
          if(state.isHost) {
            state.playerCard = hCard;
            state.opponentCard = gCard;
          } else {
            state.playerCard = gCard;
            state.opponentCard = hCard;
          }

          gameData.hostPlayed = false;
          gameData.guestPlayed = false;
          gameData.hostCard = null;
          gameData.guestCard = null;
          gameData.lastUpdate = Date.now();
          localStorage.setItem('war_game_' + code, JSON.stringify(gameData));

          resolveBattleOnline(hCard, gCard, state.isHost, gameData, code);
        } else if(opponentPlayed && !state.canPlay && !opponentShouldGoFirst) {
          state.message = '‚è≥ Przeciwnik zagra≈Ç! Czekam na rozwiƒÖzanie...';
          render();
        }

        if(state.isHost) {
          if(gameData.hostDeck) state.playerDeck = gameData.hostDeck.slice();
          if(gameData.guestDeck) state.opponentDeck = gameData.guestDeck.slice();
          state.collectedPlayerCards = gameData.hostCollected || 0;
          state.collectedOpponentCards = gameData.guestCollected || 0;
          if(gameData.hostActiveIcons) state.myActiveIcons = gameData.hostActiveIcons;
          if(gameData.guestActiveIcons) state.opponentActiveIcons = gameData.guestActiveIcons;
        } else {
          if(gameData.guestDeck) state.playerDeck = gameData.guestDeck.slice();
          if(gameData.hostDeck) state.opponentDeck = gameData.hostDeck.slice();
          state.collectedPlayerCards = gameData.guestCollected || 0;
          state.collectedOpponentCards = gameData.hostCollected || 0;
          if(gameData.guestActiveIcons) state.myActiveIcons = gameData.guestActiveIcons;
          if(gameData.hostActiveIcons) state.opponentActiveIcons = gameData.hostActiveIcons;
        }
        
        // Only render if NOT in lobby to prevent animation reset
        if(state.gameState !== 'lobby') {
          render();
        }
      } catch(e) {}
    }, 500);
  }

  function checkWinCondition(pCollected, oCollected) {
    if(pCollected >= 10) {
      if(oCollected >= 9 && pCollected - oCollected < 3) return null;
      return 'player';
    }
    if(oCollected >= 10) {
      if(pCollected >= 9 && oCollected - pCollected < 3) return null;
      return 'opponent';
    }
    return null;
  }

  function playCard() {
    if(!state.canPlay || state.isProcessing || state.playerDeck.length === 0) return;

    const card = state.playerDeck[0];
    const newPlayerDeck = state.playerDeck.slice(1);
    state.playerDeck = newPlayerDeck;
    state.playerCard = card;
    state.canPlay = false;
    render();

    if(state.gameMode === 'bot') {
      if(state.lastWinner === 'opponent') {
        if(state.opponentCard) {
          resolveBattleLocal(card, state.opponentCard);
        } else {
          state.message = '‚è≥ Czekam na bota...';
          render();
        }
      } else {
        state.message = '‚è≥ Czekam na bota...';
        render();
        setTimeout(() => {
          if(state.opponentDeck.length === 0) {
            endGame('player');
            return;
          }
          const oppCard = state.opponentDeck[0];
          state.opponentDeck = state.opponentDeck.slice(1);
          state.opponentCard = oppCard;
          render();
          setTimeout(() => resolveBattleLocal(card, oppCard), 500);
        }, 800);
      }
    } else {
      try {
        const raw = localStorage.getItem('war_game_' + state.roomCode) || '{}';
        const gameData = JSON.parse(raw);
        
        if(state.isHost) {
          gameData.hostCard = card;
          gameData.hostPlayed = true;
          const newHostDeck = [...(gameData.hostDeck || [])];
          newHostDeck.shift();
          gameData.hostDeck = newHostDeck;
        } else {
          gameData.guestCard = card;
          gameData.guestPlayed = true;
          const newGuestDeck = [...(gameData.guestDeck || [])];
          newGuestDeck.shift();
          gameData.guestDeck = newGuestDeck;
        }
        
        gameData.lastUpdate = Date.now();
        localStorage.setItem('war_game_' + state.roomCode, JSON.stringify(gameData));
        state.message = '‚è≥ Czekam na przeciwnika...';
        render();
      } catch(e) {
        alert('B≈ÇƒÖd zapisu stanu gry (localStorage).');
      }
    }
  }

  function resolveBattleLocal(pCard, oCard) {
    state.isProcessing = true;
    render();
    
    setTimeout(() => {
      const pValue = pCard.overall;
      const oValue = oCard.overall;
      let newLastWinner = state.lastWinner;
      
      if(pValue > oValue) {
        state.collectedPlayerCards++;
        let msg = `‚úÖ Wygra≈Çe≈õ rundƒô! ${pCard.name} (${pValue}) > ${oCard.name} (${oValue})`;
        newLastWinner = 'player';
        state.lastRoundWinner = 'player';
        
        if(oCard.type === 'icon') {
          state.opponentActiveIcons = state.opponentActiveIcons.filter(ic => ic.name !== oCard.name);
          msg += ` üí• Zniszczy≈Çe≈õ legendƒô przeciwnika!`;
        }
        state.message = msg;
        
        const winCheck = checkWinCondition(state.collectedPlayerCards, state.collectedOpponentCards);
        if(winCheck === 'player') {
          endGame('player');
          return;
        }
      } else if(oValue > pValue) {
        state.collectedOpponentCards++;
        let msg = `‚ùå Przegra≈Çe≈õ rundƒô! ${oCard.name} (${oValue}) > ${pCard.name} (${pValue})`;
        newLastWinner = 'opponent';
        state.lastRoundWinner = 'opponent';
        
        if(pCard.type === 'icon') {
          state.myActiveIcons = state.myActiveIcons.filter(ic => ic.name !== pCard.name);
          msg += ` üíî Straci≈Çe≈õ swojƒÖ legendƒô!`;
        }
        state.message = msg;
        
        const winCheck = checkWinCondition(state.collectedPlayerCards, state.collectedOpponentCards);
        if(winCheck === 'opponent') {
          endGame('opponent');
          return;
        }
      } else {
        state.message = `‚öñÔ∏è Remis! ${pCard.name} = ${oCard.name} (${pValue})`;
        state.lastRoundWinner = null;
      }

      render(); // Show winner border immediately

      setTimeout(() => {
        state.playerCard = null;
        state.opponentCard = null;
        state.isProcessing = false;
        state.lastWinner = newLastWinner;
        state.lastRoundWinner = null; // Clear winner border
        
        if(newLastWinner === 'player') {
          state.canPlay = true;
          state.message = 'üéÆ Twoja kolej! Kliknij "Wy≈Ç√≥≈º kartƒô"';
        } else {
          state.canPlay = false;
          state.message = '‚è≥ Kolej bota...';
          render();
          
          setTimeout(() => {
            if(state.opponentDeck.length === 0) {
              endGame('player');
              return;
            }
            const oppCard = state.opponentDeck[0];
            state.opponentDeck = state.opponentDeck.slice(1);
            state.opponentCard = oppCard;
            state.canPlay = true;
            state.message = '‚ö° Bot zagra≈Ç! Teraz Ty!';
            render();
          }, 1000);
        }
        render();
      }, 2000); // Show winner border for 2 seconds
    }, 500);
  }

  function resolveBattleOnline(hCard, gCard, amIHost, gameData, code) {
    state.isProcessing = true;
    render();
    
    setTimeout(() => {
      const pCard = amIHost ? hCard : gCard;
      const oCard = amIHost ? gCard : hCard;
      const pValue = pCard.overall;
      const oValue = oCard.overall;

      let newHostCollected = gameData.hostCollected;
      let newGuestCollected = gameData.guestCollected;
      let newLastWinner = gameData.lastWinner;

      if(pValue > oValue) {
        if(amIHost) newHostCollected++;
        else newGuestCollected++;
        newLastWinner = amIHost ? 'host' : 'guest';
        let msg = `‚úÖ Wygra≈Çe≈õ rundƒô! ${pCard.name} (${pValue}) > ${oCard.name} (${oValue})`;
        state.lastRoundWinner = 'player';
        
        if(oCard.type === 'icon') {
          state.opponentActiveIcons = state.opponentActiveIcons.filter(ic => ic.name !== oCard.name);
          if(amIHost) gameData.guestActiveIcons = state.opponentActiveIcons;
          else gameData.hostActiveIcons = state.opponentActiveIcons;
          msg += ` üí• Zniszczy≈Çe≈õ legendƒô przeciwnika!`;
        }
        state.message = msg;
      } else if(oValue > pValue) {
        if(amIHost) newGuestCollected++;
        else newHostCollected++;
        newLastWinner = amIHost ? 'guest' : 'host';
        let msg = `‚ùå Przegra≈Çe≈õ rundƒô! ${oCard.name} (${oValue}) > ${pCard.name} (${pValue})`;
        state.lastRoundWinner = 'opponent';
        
        if(pCard.type === 'icon') {
          state.myActiveIcons = state.myActiveIcons.filter(ic => ic.name !== pCard.name);
          if(amIHost) gameData.hostActiveIcons = state.myActiveIcons;
          else gameData.guestActiveIcons = state.myActiveIcons;
          msg += ` üíî Straci≈Çe≈õ swojƒÖ legendƒô!`;
        }
        state.message = msg;
      } else {
        state.message = `‚öñÔ∏è Remis! ${pCard.name} = ${oCard.name} (${pValue})`;
        state.lastRoundWinner = null;
      }

      const newHostDeck = [...(gameData.hostDeck || [])];
      const newGuestDeck = [...(gameData.guestDeck || [])];
      newHostDeck.shift();
      newGuestDeck.shift();

      gameData.hostCollected = newHostCollected;
      gameData.guestCollected = newGuestCollected;
      gameData.lastWinner = newLastWinner;
      gameData.hostDeck = newHostDeck;
      gameData.guestDeck = newGuestDeck;
      gameData.lastUpdate = Date.now();
      
      try {
        localStorage.setItem('war_game_' + code, JSON.stringify(gameData));
      } catch(e) {}

      if(amIHost) {
        state.playerDeck = newHostDeck.slice();
        state.opponentDeck = newGuestDeck.slice();
        state.collectedPlayerCards = newHostCollected;
        state.collectedOpponentCards = newGuestCollected;
      } else {
        state.playerDeck = newGuestDeck.slice();
        state.opponentDeck = newHostDeck.slice();
        state.collectedPlayerCards = newGuestCollected;
        state.collectedOpponentCards = newHostCollected;
      }

      const winCheck = checkWinCondition(
        amIHost ? newHostCollected : newGuestCollected,
        amIHost ? newGuestCollected : newHostCollected
      );
      
      if(winCheck === 'player') {
        endGame('player');
        return;
      }
      if(winCheck === 'opponent') {
        endGame('opponent');
        return;
      }

      render(); // Show winner border immediately

      setTimeout(() => {
        state.playerCard = null;
        state.opponentCard = null;
        state.isProcessing = false;
        state.lastRoundWinner = null; // Clear winner border

        const myTurn = (amIHost && newLastWinner === 'host') || (!amIHost && newLastWinner === 'guest');
        
        if(myTurn || pValue === oValue) {
          state.canPlay = true;
          state.lastWinner = 'player';
          state.message = 'üéÆ Twoja kolej! Kliknij "Wy≈Ç√≥≈º kartƒô"';
        } else {
          state.canPlay = false;
          state.lastWinner = 'opponent';
          state.message = '‚è≥ Kolej przeciwnika, czekaj...';
        }
        render();
      }, 2000); // Show winner border for 2 seconds
    }, 500);
  }

  function endGame(winnerSide) {
    state.gameState = 'finished';
    state.winner = winnerSide;
    if(state.intervalId) {
      clearInterval(state.intervalId);
      state.intervalId = null;
    }
    render();
  }

  function resetGame() {
    if(state.intervalId) {
      clearInterval(state.intervalId);
      state.intervalId = null;
    }
    if(state.roomCode) {
      try {
        localStorage.removeItem('war_game_' + state.roomCode);
      } catch(e) {}
    }
    
    state.gameMode = null;
    state.gameState = 'menu';
    state.opponentName = 'Bot';
    state.playerDeck = [];
    state.opponentDeck = [];
    state.playerCard = null;
    state.opponentCard = null;
    state.message = '';
    state.winner = null;
    state.canPlay = true;
    state.isProcessing = false;
    state.lastWinner = 'player';
    state.lastRoundWinner = null;
    state.collectedPlayerCards = 0;
    state.collectedOpponentCards = 0;
    state.player1Icons = [];
    state.player2Icons = [];
    state.myActiveIcons = [];
    state.opponentActiveIcons = [];
    state.roomCode = '';
    state.inputRoomCode = '';
    state.isHost = false;
    state.copied = false;
    state.inputName = localStorage.getItem('war_game_player_name') || '';
    
    render();
  }

  function escapeHtml(unsafe) {
    if(!unsafe && unsafe !== 0) return '';
    return String(unsafe)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Initialize game
  (function initFromUrl() {
    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    if(room) {
      state.inputRoomCode = room.toUpperCase();
      state.inputName = localStorage.getItem('war_game_player_name') || '';
    }
    render();
  })();

  // Debug
  window.FC_WAR = { state, render, resetGame };
  </script>
</body>
</html>
