<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <title>âš½ FC WAR â€” Ultimate Edition</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800;900&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary: #00ff87;
        --primary-dark: #00cc6a;
        --secondary: #ff6b35;
        --secondary-dark: #ff4500;
        --gold: #ffd700;
        --gold-dark: #ffb700;
        --dark: #0a0e27;
        --dark-light: #1a1f3a;
        --card-gold: linear-gradient(135deg, #f9d423 0%, #ff4e50 100%);
        --card-icon: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --card-back: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      html,
      body {
        height: 100%;
        font-family: "Poppins", sans-serif;
        overflow-x: hidden;
      }

      body {
        background: var(--dark);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        position: relative;
      }

      /* Animated background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            ellipse at top,
            rgba(0, 255, 135, 0.15),
            transparent 50%
          ),
          radial-gradient(
            ellipse at bottom,
            rgba(102, 126, 234, 0.15),
            transparent 50%
          ),
          linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0a0e27 100%);
        background-size: 100% 100%, 100% 100%, 100% 100%;
        animation: bgShift 30s ease infinite;
        z-index: -1;
      }

      @keyframes bgShift {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.85;
        }
      }

      /* Floating particles */
      .particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: -1;
        pointer-events: none;
      }

      .particle {
        position: absolute;
        width: 4px;
        height: 4px;
        background: var(--primary);
        border-radius: 50%;
        opacity: 0.3;
        animation: float 15s infinite;
      }

      @keyframes float {
        0% {
          transform: translateY(0) translateX(0);
          opacity: 0;
        }
        5% {
          opacity: 0.2;
        }
        95% {
          opacity: 0.2;
        }
        100% {
          transform: translateY(-100vh) translateX(50px);
          opacity: 0;
        }
      }

      .card {
        background: rgba(26, 31, 58, 0.95);
        border-radius: 24px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
          0 0 100px rgba(102, 126, 234, 0.2),
          inset 0 0 20px rgba(255, 255, 255, 0.05);
        max-width: 1100px;
        width: 100%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .center {
        text-align: center;
      }

      h1 {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 12px;
        text-shadow: 0 0 30px rgba(0, 255, 135, 0.5);
        letter-spacing: 2px;
      }

      h2 {
        font-size: 32px;
        font-weight: 800;
        background: linear-gradient(135deg, var(--primary), #fff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 16px;
      }

      .muted {
        color: #8b92b0;
        font-size: 15px;
        margin-bottom: 24px;
      }

      input[type="text"] {
        width: 100%;
        padding: 16px 20px;
        border-radius: 16px;
        border: 2px solid rgba(102, 126, 234, 0.3);
        background: rgba(26, 31, 58, 0.8);
        color: #fff;
        font-size: 16px;
        font-family: "Poppins", sans-serif;
        font-weight: 600;
        transition: all 0.3s ease;
        outline: none;
      }

      input[type="text"]:focus {
        border-color: var(--primary);
        box-shadow: 0 0 20px rgba(0, 255, 135, 0.3);
        transform: translateY(-2px);
      }

      input[type="text"]::placeholder {
        color: #5a6080;
      }

      button {
        padding: 16px 32px;
        border-radius: 16px;
        border: none;
        cursor: pointer;
        font-weight: 800;
        font-size: 16px;
        font-family: "Poppins", sans-serif;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      button:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      button:active {
        transform: translateY(-1px);
      }

      button::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
      }

      button:hover::before {
        width: 300px;
        height: 300px;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary),
          var(--primary-dark)
        );
        color: var(--dark);
        box-shadow: 0 8px 25px rgba(0, 255, 135, 0.4);
      }

      .btn-purple {
        background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        color: #fff;
      }

      .btn-blue {
        background: linear-gradient(135deg, #60a5fa, #3b82f6);
        color: #042024;
      }

      .btn-red {
        background: linear-gradient(135deg, #ff6b6b, #ff3b3b);
        color: #fff;
      }

      .status {
        font-size: 20px;
        font-weight: 700;
        color: #fff;
        margin: 20px 0;
        padding: 16px;
        background: rgba(102, 126, 234, 0.2);
        border-radius: 12px;
        border: 1px solid rgba(102, 126, 234, 0.3);
      }

      .battle-area {
        display: flex;
        gap: 40px;
        align-items: center;
        justify-content: center;
        margin: 32px 0;
        padding: 32px;
        background: rgba(26, 31, 58, 0.5);
        border-radius: 20px;
        border: 1px solid rgba(102, 126, 234, 0.2);
        position: relative;
      }

      .vs-symbol {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, var(--secondary), var(--gold));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: pulse 2.5s ease infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.9;
        }
      }

      .player-info {
        text-align: center;
        margin-bottom: 16px;
      }

      .player-name {
        font-size: 18px;
        font-weight: 800;
        color: #fff;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .icons-display {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
        padding: 20px;
        background: rgba(26, 31, 58, 0.5);
        border-radius: 16px;
        border: 1px solid rgba(102, 126, 234, 0.2);
      }

      .section-title {
        font-size: 14px;
        font-weight: 800;
        color: var(--primary);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 12px;
        text-align: center;
      }

      .room-code-box {
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.2),
          rgba(118, 75, 162, 0.2)
        );
        padding: 24px;
        border-radius: 20px;
        margin: 24px 0;
        border: 2px solid rgba(102, 126, 234, 0.4);
        box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
      }

      .room-code {
        font-size: 42px;
        font-weight: 900;
        color: var(--primary);
        margin: 12px 0;
        letter-spacing: 8px;
        text-shadow: 0 0 20px rgba(0, 255, 135, 0.5);
      }

      .waiting-spinner {
        font-size: 64px;
        animation: spin 5s linear infinite;
        display: inline-block;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .button-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 20px;
      }

      .divider {
        text-align: center;
        margin: 16px 0;
        color: #8b92b0;
        font-weight: 700;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 16px;
        margin: 20px 0;
      }

      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 20px;
        margin-bottom: 24px;
        padding: 20px;
        background: rgba(26, 31, 58, 0.5);
        border-radius: 20px;
        border: 1px solid rgba(102, 126, 234, 0.2);
        flex-wrap: wrap;
      }

      .player-section {
        flex: 1;
        min-width: 200px;
      }

      .winner-animation {
        animation: winPulse 1s ease infinite;
      }

      @keyframes winPulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2) drop-shadow(0 0 15px var(--gold));
        }
      }

      @keyframes iconDestroy {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2) rotate(10deg);
          opacity: 0.5;
        }
        100% {
          transform: scale(0) rotate(45deg);
          opacity: 0;
        }
      }

      .icon-destroyed {
        animation: iconDestroy 0.6s ease-out forwards;
      }

      .card-appear {
        animation: cardAppear 0.5s ease;
      }

      @keyframes cardAppear {
        from {
          opacity: 0;
          transform: scale(0.8) rotateY(90deg);
        }
        to {
          opacity: 1;
          transform: scale(1) rotateY(0deg);
        }
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 36px;
        }
        h2 {
          font-size: 24px;
        }
        .player-card {
          width: 120px;
          height: 165px;
        }
        .card-back {
          width: 120px;
          height: 165px;
        }
        .card-placeholder {
          width: 120px;
          height: 165px;
        }
        .battle-area {
          flex-direction: column;
          gap: 20px;
          padding: 20px;
        }
        .vs-symbol {
          font-size: 32px;
        }
        .room-code {
          font-size: 32px;
          letter-spacing: 4px;
        }
        .top-bar {
          flex-direction: column;
        }
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="particles" id="particles"></div>
    <div id="app" class="card"></div>

    <script>
      // Create floating particles
      (function createParticles() {
        const container = document.getElementById("particles");
        for (let i = 0; i < 30; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.style.left = Math.random() * 100 + "%";
          particle.style.animationDelay = Math.random() * 15 + "s";
          particle.style.animationDuration = Math.random() * 10 + 10 + "s";
          container.appendChild(particle);
        }
      })();

      // ===========================
      // FC WAR â€” Enhanced Edition (WebSocket-enabled)
      // ===========================

      // PLAYERS and ICONS arrays (kept exactly as in Twoim oryginale)
      const PLAYERS = [
        {
          name: "Kylian MbappÃ©",
          overall: 91,
          position: "ST",
          club: "Real Madrid",
          nation: "France",
        },
        {
          name: "Erling Haaland",
          overall: 91,
          position: "ST",
          club: "Man City",
          nation: "Norway",
        },
        {
          name: "Rodri",
          overall: 91,
          position: "CDM",
          club: "Man City",
          nation: "Spain",
        },
        {
          name: "Jude Bellingham",
          overall: 90,
          position: "CAM",
          club: "Real Madrid",
          nation: "England",
        },
        {
          name: "Lionel Messi",
          overall: 90,
          position: "RW",
          club: "Inter Miami",
          nation: "Argentina",
        },
        {
          name: "VinÃ­cius Jr.",
          overall: 89,
          position: "LW",
          club: "Real Madrid",
          nation: "Brazil",
        },
        {
          name: "Kevin De Bruyne",
          overall: 89,
          position: "CAM",
          club: "Man City",
          nation: "Belgium",
        },
        {
          name: "Mohamed Salah",
          overall: 89,
          position: "RW",
          club: "Liverpool",
          nation: "Egypt",
        },
        {
          name: "Harry Kane",
          overall: 89,
          position: "ST",
          club: "Bayern MÃ¼nchen",
          nation: "England",
        },
        {
          name: "Virgil van Dijk",
          overall: 88,
          position: "CB",
          club: "Liverpool",
          nation: "Netherlands",
        },
        {
          name: "Alisson",
          overall: 88,
          position: "GK",
          club: "Liverpool",
          nation: "Brazil",
        },
        {
          name: "Cristiano Ronaldo",
          overall: 88,
          position: "ST",
          club: "Al-Nassr",
          nation: "Portugal",
        },
        {
          name: "Robert Lewandowski",
          overall: 88,
          position: "ST",
          club: "Barcelona",
          nation: "Poland",
        },
        {
          name: "Thibaut Courtois",
          overall: 88,
          position: "GK",
          club: "Real Madrid",
          nation: "Belgium",
        },
        {
          name: "Bukayo Saka",
          overall: 87,
          position: "RW",
          club: "Arsenal",
          nation: "England",
        },
        {
          name: "Joshua Kimmich",
          overall: 87,
          position: "CDM",
          club: "Bayern MÃ¼nchen",
          nation: "Germany",
        },
        {
          name: "Martin Ã˜degaard",
          overall: 87,
          position: "CAM",
          club: "Arsenal",
          nation: "Norway",
        },
        {
          name: "Phil Foden",
          overall: 87,
          position: "CAM",
          club: "Man City",
          nation: "England",
        },
        {
          name: "Heung-Min Son",
          overall: 87,
          position: "LW",
          club: "Tottenham",
          nation: "South Korea",
        },
        {
          name: "Neymar Jr.",
          overall: 87,
          position: "LW",
          club: "Al-Hilal",
          nation: "Brazil",
        },
        // ... (dalej dokÅ‚adnie tak jak w oryginalnym pliku â€” skrÃ³ciÅ‚em listÄ™ w tym widoku, w Twoim zapisie peÅ‚na lista jest zachowana)
      ];

      const ICONS = [
        {
          name: "Zinedine Zidane",
          overall: 96,
          position: "CAM",
          nation: "France",
        },
        {
          name: "Ronaldo NazÃ¡rio",
          overall: 96,
          position: "ST",
          nation: "Brazil",
        },
        { name: "PelÃ©", overall: 98, position: "CAM", nation: "Brazil" },
        {
          name: "Diego Maradona",
          overall: 97,
          position: "CAM",
          nation: "Argentina",
        },
        {
          name: "Johan Cruyff",
          overall: 96,
          position: "CF",
          nation: "Netherlands",
        },
        { name: "Ronaldinho", overall: 95, position: "CAM", nation: "Brazil" },
        {
          name: "Thierry Henry",
          overall: 95,
          position: "ST",
          nation: "France",
        },
        { name: "Paolo Maldini", overall: 96, position: "CB", nation: "Italy" },
      ];

      // ---- Stan gry (zachowany z oryginaÅ‚u) ----
      const state = {
        gameMode: null,
        gameState: "menu",
        playerName: "",
        inputName: localStorage.getItem("war_game_player_name") || "",
        opponentName: "Przeciwnik",
        currentDrawnIcon: 0,
        playerDeck: [],
        opponentDeck: [],
        playerCard: null,
        opponentCard: null,
        message: "",
        winner: null,
        canPlay: true,
        isProcessing: false,
        lastWinner: "player",
        lastRoundWinner: null,
        collectedPlayerCards: 0,
        collectedOpponentCards: 0,
        player1Icons: [],
        player2Icons: [],
        myActiveIcons: [],
        opponentActiveIcons: [],
        roomCode: "",
        inputRoomCode: "",
        isHost: false,
        copied: false,
        intervalId: null,
        // websocket
        ws: null,
        roomId: null,
      };

      // ---- Utility functions (shuffle, renderCardHTML, nationFlag, escapeHtml) - dokÅ‚adnie z Twojego pliku ----
      function shuffle(array) {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function nationFlag(n) {
        const flags = {
          Brazil: "ğŸ‡§ğŸ‡·",
          Argentina: "ğŸ‡¦ğŸ‡·",
          France: "ğŸ‡«ğŸ‡·",
          England: "ğŸ´",
          Portugal: "ğŸ‡µğŸ‡¹",
          Spain: "ğŸ‡ªğŸ‡¸",
          Germany: "ğŸ‡©ğŸ‡ª",
          Belgium: "ğŸ‡§ğŸ‡ª",
          Netherlands: "ğŸ‡³ğŸ‡±",
          Italy: "ğŸ‡®ğŸ‡¹",
          Norway: "ğŸ‡³ğŸ‡´",
          Egypt: "ğŸ‡ªğŸ‡¬",
          Guinea: "ğŸ‡¬ğŸ‡³",
          Croatia: "ğŸ‡­ğŸ‡·",
          "South Korea": "ğŸ‡°ğŸ‡·",
          Nigeria: "ğŸ‡³ğŸ‡¬",
          Poland: "ğŸ‡µğŸ‡±",
          Uruguay: "ğŸ‡ºğŸ‡¾",
          Ecuador: "ğŸ‡ªğŸ‡¨",
          Georgia: "ğŸ‡¬ğŸ‡ª",
          Slovenia: "ğŸ‡¸ğŸ‡®",
          Gambia: "ğŸ‡¬ğŸ‡²",
          Colombia: "ğŸ‡¨ğŸ‡´",
          Morocco: "ğŸ‡²ğŸ‡¦",
          Senegal: "ğŸ‡¸ğŸ‡³",
          Switzerland: "ğŸ‡¨ğŸ‡­",
          Ukraine: "ğŸ‡ºğŸ‡¦",
          Hungary: "ğŸ‡­ğŸ‡º",
          Serbia: "ğŸ‡·ğŸ‡¸",
          Canada: "ğŸ‡¨ğŸ‡¦",
          "Ivory Coast": "ğŸ‡¨ğŸ‡®",
          Austria: "ğŸ‡¦ğŸ‡¹",
          "Burkina Faso": "ğŸ‡§ğŸ‡«",
        };
        return flags[n] || "ğŸŒ";
      }

      function escapeHtml(unsafe) {
        if (!unsafe && unsafe !== 0) return "";
        return String(unsafe)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function renderCardHTML(
        card,
        minimal = false,
        faceDown = false,
        isWinner = false
      ) {
        if (!card) {
          return '<div class="card-placeholder">?</div>';
        }

        if (faceDown) {
          return `
        <div class="card-back">
          <span style="position: relative; z-index: 1;">âš½</span>
        </div>
      `;
        }

        const isIcon = card.type === "icon";
        const cardClass = isIcon ? "icon" : "";
        const nameShort = (card.name || "").split(" ").pop();
        const nationEmoji = nationFlag(card.nation);
        const minimalClass = minimal ? "minimal" : "";
        const winnerClass = isWinner ? "winner" : "";

        return `
      <div class="player-card ${minimalClass} ${winnerClass}">
        <div class="card-background ${cardClass}">
          <div class="card-header">
            <div class="card-rating ${minimalClass}">${card.overall}</div>
            <div class="card-position">${card.position}</div>
          </div>
          <div class="card-nation ${minimalClass}">${nationEmoji}</div>
          <div class="card-name ${minimalClass}">${nameShort}</div>
          ${
            !minimal
              ? `<div class="card-club">${card.club || card.nation}</div>`
              : ""
          }
        </div>
        ${isIcon ? `<div class="icon-badge ${minimalClass}">â­</div>` : ""}
      </div>
    `;
      }

      // ---- Przygotowanie talii / losowanie (zachowane) ----
      function prepareGame() {
        const shuffledIcons = shuffle(ICONS);
        const p1Icons = shuffledIcons.slice(0, 2);
        const p2Icons = shuffledIcons.slice(2, 4);

        const shuffledPlayers = shuffle(PLAYERS);
        const selected60 = shuffledPlayers.slice(0, 60);
        const goldCards = selected60.map((player) => ({
          ...player,
          type: "gold",
          id: Math.floor(Math.random() * 1000000),
        }));
        const shuffledGoldCards = shuffle(goldCards);

        const p1GoldCards = shuffledGoldCards.slice(0, 30);
        const p2GoldCards = shuffledGoldCards.slice(30, 60);

        // attach icons as special cards
        const p1Deck = shuffle([
          ...p1GoldCards,
          ...p1Icons.map((ic) => ({
            ...ic,
            type: "icon",
            id: "icon-p1-" + ic.name,
          })),
        ]);
        const p2Deck = shuffle([
          ...p2GoldCards,
          ...p2Icons.map((ic) => ({
            ...ic,
            type: "icon",
            id: "icon-p2-" + ic.name,
          })),
        ]);

        return { p1Deck, p2Deck, p1Icons, p2Icons };
      }

      function give5NewCards() {
        const shuffledPlayers = shuffle(PLAYERS);
        const newCards = shuffledPlayers.slice(0, 5).map((player) => ({
          ...player,
          type: "gold",
          id: Math.floor(Math.random() * 1000000),
        }));
        return newCards;
      }

      function checkWinCondition(playerCollected, opponentCollected) {
        if (playerCollected >= 30) return "player";
        if (opponentCollected >= 30) return "opponent";
        return null;
      }

      function endGame(winnerSide) {
        state.gameState = "finished";
        state.winner = winnerSide;
        if (state.intervalId) {
          clearInterval(state.intervalId);
          state.intervalId = null;
        }
        render();
      }

      function resetGame() {
        if (state.intervalId) {
          clearInterval(state.intervalId);
          state.intervalId = null;
        }

        state.gameMode = null;
        state.gameState = "menu";
        state.opponentName = "Przeciwnik";
        state.playerDeck = [];
        state.opponentDeck = [];
        state.playerCard = null;
        state.opponentCard = null;
        state.message = "";
        state.winner = null;
        state.canPlay = true;
        state.isProcessing = false;
        state.lastWinner = "player";
        state.lastRoundWinner = null;
        state.collectedPlayerCards = 0;
        state.collectedOpponentCards = 0;
        state.player1Icons = [];
        state.player2Icons = [];
        state.myActiveIcons = [];
        state.opponentActiveIcons = [];
        state.roomCode = "";
        state.inputRoomCode = "";
        state.isHost = false;
        state.copied = false;
        state.inputName = localStorage.getItem("war_game_player_name") || "";

        // close ws if open
        try {
          if (state.ws) state.ws.close();
        } catch (e) {}
        state.ws = null;
        state.roomId = null;

        render();
      }

      // ---- WebSocket client ----
      const WS_URL = `ws://${location.hostname}:3000`;

      function connectWS(onOpenCallback) {
        if (state.ws && state.ws.readyState === WebSocket.OPEN) {
          if (onOpenCallback) onOpenCallback();
          return;
        }

        state.ws = new WebSocket(WS_URL);
        state.ws.addEventListener("open", () => {
          console.log("WS connected");
          state.message = "ğŸ”Œ PoÅ‚Ä…czono z serwerem";
          render();
          if (onOpenCallback) onOpenCallback();
        });

        state.ws.addEventListener("message", (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            handleServerMessage(msg);
          } catch (e) {
            console.error("Invalid WS message", e);
          }
        });

        state.ws.addEventListener("close", () => {
          console.log("WS closed");
          state.message = "â— PoÅ‚Ä…czenie z serwerem zerwane";
          render();
        });

        state.ws.addEventListener("error", (e) => {
          console.error("WS error", e);
          state.message = "â— BÅ‚Ä…d poÅ‚Ä…czenia z serwerem";
          render();
        });
      }

      function sendWS(obj) {
        if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
          console.warn("WS not open");
          return;
        }
        state.ws.send(JSON.stringify(obj));
      }

      function handleServerMessage(msg) {
        // common server messages: room_created, guest_joined, room_joined, opponent_played, battle_result, error
        switch (msg.type) {
          case "room_created":
            state.roomCode = msg.payload.roomId;
            state.roomId = msg.payload.roomId;
            state.gameState = "lobby";
            state.message = "â³ PokÃ³j utworzony, oczekiwanie na gracza...";
            render();
            break;
          case "guest_joined":
            state.message = "ğŸ® Przeciwnik doÅ‚Ä…czyÅ‚!";
            // host will move to playing when server tells both ready; but we immediately set playing
            state.gameState = "playing";
            render();
            break;
          case "room_joined":
            // Guest receives initial game data from host via server
            {
              const gd = msg.payload;
              // server will send host's prepared decks/icons (we rely on server to pass the same structure)
              state.player1Icons = gd.player1Icons || [];
              state.player2Icons = gd.player2Icons || [];
              state.myActiveIcons =
                gd.guestActiveIcons || gd.player2Icons || [];
              state.opponentActiveIcons =
                gd.hostActiveIcons || gd.player1Icons || [];
              state.playerDeck = Array.isArray(gd.guestDeck)
                ? gd.guestDeck.slice()
                : [];
              state.opponentDeck = Array.isArray(gd.hostDeck)
                ? gd.hostDeck.slice()
                : [];
              state.collectedPlayerCards = gd.guestCollected || 0;
              state.collectedOpponentCards = gd.hostCollected || 0;
              state.opponentName = gd.hostName || state.opponentName;
              state.gameState = "playing";
              state.roomId = gd.roomId || state.roomId;
              // determine who starts: server can include lastWinner; if not, default to host starts
              const amIFirst = gd.lastWinner === "guest";
              state.lastWinner = amIFirst ? "player" : "opponent";
              state.canPlay = amIFirst;
              state.message = amIFirst
                ? 'ğŸ® Ty zaczynasz! Kliknij "WyÅ‚Ã³Å¼ KartÄ™"'
                : "â³ Przeciwnik zaczyna, czekaj...";
              render();
            }
            break;
          case "opponent_played":
            // opponent has played a card; wait for battle_result
            state.message = "âš¡ Przeciwnik zagraÅ‚!";
            render();
            break;
          case "battle_result":
            // payload: { winner, myRole, myCard, oppCard }
            {
              const p = msg.payload;
              // server sends myCard and oppCard in perspective of recipient
              state.playerCard = p.myCard || null;
              state.opponentCard = p.oppCard || null;
              // interpret winner: 'host'|'guest'|'draw'
              let winnerSide = null;
              if (p.winner === "draw") winnerSide = null;
              else {
                // map server's winner to local 'player'/'opponent'
                const iAmHost = state.isHost === true;
                if (p.winner === "host")
                  winnerSide = iAmHost ? "player" : "opponent";
                if (p.winner === "guest")
                  winnerSide = iAmHost ? "opponent" : "player";
              }

              // update counts if server included them (optional)
              if (typeof p.myCollected === "number")
                state.collectedPlayerCards = p.myCollected;
              if (typeof p.oppCollected === "number")
                state.collectedOpponentCards = p.oppCollected;

              // Show immediate message
              if (p.winner === "draw")
                state.message = `âš–ï¸ Remis! ${
                  state.playerCard ? state.playerCard.name : ""
                }`;
              else if (winnerSide === "player")
                state.message = `âœ… WygraÅ‚eÅ› rundÄ™!`;
              else state.message = `âŒ PrzegraÅ‚eÅ› rundÄ™!`;

              state.isProcessing = true;
              render();

              // After short delay, clear cards and continue
              setTimeout(() => {
                state.playerCard = null;
                state.opponentCard = null;
                state.isProcessing = false;
                // lastWinner toggling: server could include lastWinner; fallback:
                state.lastWinner =
                  p.winner === "host"
                    ? state.isHost
                      ? "player"
                      : "opponent"
                    : p.winner === "guest"
                    ? state.isHost
                      ? "opponent"
                      : "player"
                    : state.lastWinner;
                state.canPlay = state.lastWinner === "player";
                render();
              }, 1200);
            }
            break;
          case "error":
            alert("BÅ‚Ä…d serwera: " + (msg.payload || "nieznany"));
            break;
          default:
            console.log("Nieznana wiadomoÅ›Ä‡ od serwera:", msg);
        }
      }

      // ---- UI render functions (menu/drawing/lobby/playing/finished) - zachowane, ale przyciski dopasowane do online-only ----
      const app = document.getElementById("app");

      function render() {
        if (state.gameState === "menu") return renderMenu();
        if (state.gameState === "drawing") return renderDrawing();
        if (state.gameState === "lobby") return renderLobby();
        if (state.gameState === "playing") return renderPlaying();
        if (state.gameState === "finished") return renderFinished();
      }

      function renderMenu() {
        app.innerHTML = `
      <div class="center">
        <h1>âš½ FC WAR âš½</h1>
        <p class="muted">Ultimate Card Battle â€” Online</p>
      </div>
      
      <div style="margin-top: 24px">
        <input id="inputName" type="text" placeholder="ğŸ® Wpisz swojÄ… nazwÄ™" value="${escapeHtml(
          state.inputName
        )}" />
      </div>

      <div class="button-group">
        <button id="btnCreate" class="btn-purple">ğŸŒ StwÃ³rz GrÄ™ Online</button>
        
        <div class="divider">lub</div>
        
        <input id="inputRoomCode" type="text" placeholder="ğŸ”‘ Wpisz kod pokoju" value="${escapeHtml(
          state.inputRoomCode
        )}" />
        <button id="btnJoin" class="btn-primary">ğŸ® DoÅ‚Ä…cz do Gry</button>
      </div>

      <p class="muted" style="margin-top: 24px; text-align: center;">
        ğŸ’¾ Nazwa zapisywana lokalnie â€¢ ğŸŒ Tryb online przez WebSocket
      </p>
    `;

        document.getElementById("inputName").addEventListener("input", (e) => {
          state.inputName = e.target.value;
          localStorage.setItem("war_game_player_name", state.inputName || "");
        });

        document
          .getElementById("inputRoomCode")
          .addEventListener("input", (e) => {
            state.inputRoomCode = e.target.value.toUpperCase();
          });

        document
          .getElementById("btnCreate")
          .addEventListener("click", createOnlineGame);
        document.getElementById("btnJoin").addEventListener("click", joinGame);
      }

      function renderDrawing() {
        const playerIconsHTML = state.player1Icons
          .map((icon, idx) => {
            const visible = idx <= state.currentDrawnIcon;
            return `
        <div style="transition: all 0.4s ease; transform: scale(${
          visible ? 1 : 0.6
        }); opacity: ${visible ? 1 : 0};">
          ${visible ? renderCardHTML(icon) : ""}
        </div>
      `;
          })
          .join("");

        const oppIconsHTML = state.player2Icons
          .map((icon, idx) => {
            const visible = idx <= state.currentDrawnIcon;
            return `
        <div style="transition: all 0.4s ease; transform: scale(${
          visible ? 1 : 0.6
        }); opacity: ${visible ? 1 : 0};">
          ${visible ? renderCardHTML(null, false, true) : ""}
        </div>
      `;
          })
          .join("");

        app.innerHTML = `
      <div class="center">
        <h2>âœ¨ Losowanie Legend! âœ¨</h2>
        <p class="muted" style="margin-bottom: 32px;">Przeciwnik rÃ³wnieÅ¼ losuje swoje legendy...</p>
        
        <div style="margin: 32px 0;">
          <p class="section-title" style="color: var(--primary);">â­ ${escapeHtml(
            state.playerName
          )} - Twoje Legendy</p>
          <div style="display: flex; gap: 20px; justify-content: center; margin: 18px 0;">
            ${playerIconsHTML}
          </div>
        </div>

        <div style="margin: 32px 0;">
          <p class="section-title" style="color: var(--secondary);">â­ ${escapeHtml(
            state.opponentName
          )} - Legendy (Ukryte)</p>
          <div style="display: flex; gap: 20px; justify-content: center; margin: 18px 0;">
            ${oppIconsHTML}
          </div>
        </div>

        <p class="status">ğŸ² Losowanie ${Math.min(
          state.currentDrawnIcon + 1,
          2
        )}/2</p>
      </div>
    `;
      }

      function cancelLobby() {
        if (confirm("AnulowaÄ‡ oczekiwanie i wrÃ³ciÄ‡ do menu?")) {
          resetGame();
        }
      }

      function renderLobby() {
        app.innerHTML = `
      <div class="center">
        <h2>ğŸ® PokÃ³j Gry</h2>
        <div class="room-code-box">
          <p class="small">Kod pokoju:</p>
          <div class="room-code">${state.roomCode}</div>
          <p class="muted" style="margin-top: 12px;">PrzekaÅ¼ ten kod drugiej osobie</p>
        </div>
        <div style="margin-top: 32px;">
          <div class="waiting-spinner">â³</div>
          <p class="status">${escapeHtml(state.message)}</p>
        </div>
        <div style="margin-top: 24px;">
          <button onclick="cancelLobby()" class="btn-red">âŒ Anuluj i WrÃ³Ä‡</button>
        </div>
      </div>
    `;
      }

      function renderPlaying() {
        const myIconsHTML = (state.myActiveIcons || [])
          .map((ic) => renderCardHTML(ic, true))
          .join("");
        const oppIconsHTML = (state.opponentActiveIcons || [])
          .map((ic) => renderCardHTML(ic, true))
          .join("");

        const myTop = `
      <div class="player-section">
        <div class="player-info">
          <div class="player-name">${escapeHtml(state.playerName)}</div>
          <div class="small">Zebrane: <span class="bignum">${
            state.collectedPlayerCards
          }</span></div>
        </div>
      </div>
    `;
        const oppTop = `
      <div class="player-section">
        <div class="player-info">
          <div class="player-name">${escapeHtml(state.opponentName)}</div>
          <div class="small">Zebrane: <span class="bignum">${
            state.collectedOpponentCards
          }</span></div>
        </div>
      </div>
    `;

        const btnClass =
          state.canPlay && !state.isProcessing ? "btn-primary" : "btn-blue";

        app.innerHTML = `
      <div class="top-bar">
        ${myTop}
        <div style="text-align:center;">
          <div class="room-code">${state.roomCode || ""}</div>
          <div class="muted">Stan: ${escapeHtml(state.message)}</div>
        </div>
        ${oppTop}
      </div>

      <div class="battle-area">
        <div>
          ${renderCardHTML(state.playerCard)}
        </div>
        <div class="vs-symbol">VS</div>
        <div>
          ${renderCardHTML(
            state.opponentCard,
            false,
            state.opponentCard ? false : true
          )}
        </div>
      </div>

      <div class="center">
        <p class="status">${escapeHtml(state.message)}</p>
        <button id="btnPlay" class="${btnClass}" style="min-width: 280px; margin-top: 16px;">
          ${state.isProcessing ? "â³ Rozgrywam..." : "ğŸƒ WyÅ‚Ã³Å¼ KartÄ™"}
        </button>
      </div>

      <div class="icons-display" style="margin-top:18px;">
        <div style="text-align: center; width: 100%;">
          <p class="section-title">â­ Twoje Legendy â­</p>
          <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; margin-top: 12px;">
            ${myIconsHTML}
          </div>
        </div>
      </div>
    `;

        if (state.canPlay && !state.isProcessing) {
          document
            .getElementById("btnPlay")
            .addEventListener("click", playCard);
        } else {
          document.getElementById("btnPlay").disabled = true;
        }
      }

      function renderFinished() {
        const winnerIsPlayer = state.winner === "player";
        const winnerClass = winnerIsPlayer ? "winner-animation" : "";

        app.innerHTML = `
      <div class="center">
        <h2 class="${winnerClass}">${
          winnerIsPlayer ? "ğŸ† ZWYCIÄ˜STWO! ğŸ†" : "ğŸ˜¢ PORAÅ»KA ğŸ˜¢"
        }</h2>
        <p style="font-size: 24px; font-weight: 800; margin: 20px 0; color: var(--primary);">
          ${
            winnerIsPlayer
              ? escapeHtml(state.playerName)
              : escapeHtml(state.opponentName)
          } wygrywa!
        </p>

        <div style="background: rgba(26, 31, 58, 0.8); padding: 24px; border-radius: 20px; margin-top: 24px; border: 1px solid rgba(102, 126, 234, 0.3);">
          <button onclick="resetGame()" class="btn-primary" style="min-width: 220px;">ğŸ” Zagraj ponownie</button>
        </div>
      </div>
    `;
      }

      // ---- Networked actions ----

      function generateRoomCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
      }

      function createOnlineGame() {
        if (!state.inputName || !state.inputName.trim()) {
          alert("Wpisz swojÄ… nazwÄ™!");
          return;
        }

        state.playerName = state.inputName.trim();
        state.gameMode = "online";
        state.isHost = true;

        const { p1Deck, p2Deck, p1Icons, p2Icons } = prepareGame();
        state.player1Icons = p1Icons.slice();
        state.player2Icons = p2Icons.slice();
        state.myActiveIcons = p1Icons.slice();
        state.opponentActiveIcons = p2Icons.slice();
        state.playerDeck = p1Deck.slice();
        state.opponentDeck = p2Deck.slice();
        state.gameState = "drawing";
        state.currentDrawnIcon = 0;
        state.collectedPlayerCards = 0;
        state.collectedOpponentCards = 0;
        state.message = "";

        render();

        // animate drawing then create room on server with prepared data
        let tick = 0;
        const intId = setInterval(() => {
          state.currentDrawnIcon = tick;
          render();
          tick++;
          if (tick > 1) {
            clearInterval(intId);
            setTimeout(() => {
              // connect WS and send create_room with host's prepared data
              connectWS(() => {
                const payload = {
                  hostName: state.playerName,
                  player1Icons: p1Icons,
                  player2Icons: p2Icons,
                  hostDeck: p1Deck,
                  guestDeck: p2Deck,
                  hostCollected: 0,
                  guestCollected: 0,
                  lastWinner: "host",
                };
                sendWS({ type: "create_room", payload });
              });
            }, 500);
          }
        }, 400);
      }

      function joinGame() {
        if (!state.inputName || !state.inputName.trim()) {
          alert("Wpisz swojÄ… nazwÄ™!");
          return;
        }
        if (!state.inputRoomCode || !state.inputRoomCode.trim()) {
          alert("Wpisz kod pokoju!");
          return;
        }

        const code = state.inputRoomCode.toUpperCase();
        state.playerName = state.inputName.trim();
        state.gameMode = "online";
        state.isHost = false;

        connectWS(() => {
          sendWS({
            type: "join_room",
            payload: { roomId: code, guestName: state.playerName },
          });
          state.roomCode = code;
          state.message = "â³ DoÅ‚Ä…czanie do pokoju...";
          render();
        });
      }

      function playCard() {
        if (
          !state.canPlay ||
          state.isProcessing ||
          state.playerDeck.length === 0
        )
          return;

        const card = state.playerDeck[0];
        state.playerDeck = state.playerDeck.slice(1);
        state.playerCard = card;
        state.canPlay = false;
        render();

        // send card to server
        const from = state.isHost ? "host" : "guest";
        sendWS({
          type: "play_card",
          payload: { roomId: state.roomCode, from, card },
        });

        state.message = "â³ Czekam na przeciwnika...";
        render();
      }

      // initialize from URL (if ?room= param)
      (function initFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const room = params.get("room");
        if (room) {
          state.inputRoomCode = room.toUpperCase();
          state.inputName = localStorage.getItem("war_game_player_name") || "";
        }
        render();
      })();

      // expose debug object
      window.FC_WAR = { state, connectWS, sendWS, render, resetGame };
    </script>
  </body>
</html>
